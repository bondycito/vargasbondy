<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Still With You - Korean version</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            height: 100%;
        }
        body {
            background: black;
            overflow: hidden;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100vh;
            cursor: crosshair;
        }
        #subtitles {
            position: absolute;
            top: 5%;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            text-align: center;
            color: #fff799;
            font-family: sans-serif;
            font-size: 1.2rem;
            text-shadow: 1px 1px 2px #000;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            white-space: pre-wrap;
        }
        #subtitles.active {
            opacity: 1;
        }
    </style>
</head>
<body>
    <canvas id="scene"></canvas>
    <audio id="background-music" src="musica.mp3" loop></audio>
    <div id="subtitles"></div>
    <script>
        const canvas = document.getElementById("scene");
        const ctx = canvas.getContext("2d");
        const audio = document.getElementById("background-music");
        const subtitlesDiv = document.getElementById("subtitles");
        const dpr = Math.min(1.5, window.devicePixelRatio || 1);
        let cw = window.innerWidth;
        let ch = window.innerHeight;
        let baseX, baseY;
        const STAR_COUNT = 80;
        const SHOOTING_STAR_COUNT = 1;
        const FLOWER_COUNT = 7;
        const PARTICLE_CLICK_COUNT = 8;
        const PARTICLE_MOUSE_COUNT = 0.1;
        const stars = [];
        let shootingStars = [];
        let particles = [];
        const flowers = [];
        const colors = {
            sky1: "#0a0220",
            sky2: "#120a40",
            sky3: "#1b1035",
            sky4: "#241a2e",
            horizon: "#3a1d1d",
            stemLight: "#3ba55d",
            stemDark: "#0a1f0a",
            leafBright: "#4caf50",
            leafMid: "#2e7d32",
            leafDark: "#0a2f12",
            petalLight: "#fff799",
            petalMid: "#ffe066",
            petalDark: "#ffcc00",
            center1: "#e6b53a",
            center2: "#5a3a00",
            glow: "rgba(255,255,200,0.95)"
        };
        const lyricsData = [
            { text: "날 스치는 그대의 옅은 그 목소리\n(Tu voz tenue que me roza)", start: 3, end: 7 },
            { text: "내 이름을 한 번만 더 불러주세요\n(Por favor, llama mi nombre una vez más)", start: 8, end: 12 },
            { text: "얼어버린 노을 아래 멈춰 서있지만\n(Aunque estoy parado bajo el atardecer congelado)", start: 13, end: 18 },
            { text: "그대 향해 한 걸음씩 걸어갈래요\n(Caminaré hacia ti paso a paso)", start: 19, end: 23 },
            { text: "♪ ♪ ♪ ♪ ♪ ♪", start: 23, end: 46 },
            { text: "어두운 방 조명 하나 없이\n(En la habitación oscura sin una sola luz)", start: 47, end: 51 },
            { text: "익숙해지면 안 되는데\n(Aunque no debería acostumbrarme)", start: 52, end: 55 },
            { text: "그게 또 익숙해\n(Pero se siente familiar de nuevo)", start: 55, end: 57 },
            { text: "나지막이 들리는 이 에어컨 소리\n(El sutil sonido del aire acondicionado)", start: 57, end: 62 },
            { text: "이거라도 없으면 나 정말 무너질 것 같아\n(Si no tuviera ni esto, creo que me derrumbaría)", start: 62, end: 66 },
            { text: "♪ ♪ ♪ ♪ ♪ ♪", start: 66, end: 68 },
            { text: "함께 웃고 함께 울고\n(Riendo juntos, llorando juntos)", start: 68, end: 72 },
            { text: "이 단순한 감정들이\n(Estas simples emociones)", start: 74, end: 76 },
            { text: "내겐 전부였나봐\n(quizás eran todo para mí)", start: 76, end: 81 },
            { text: "언제쯤일까\n(¿Cuándo será?)", start: 84, end: 87 },
            { text: "다시 그댈 마주한다면\n(Cuando te vuelva a ver)", start: 88, end: 90 },
            { text: "눈을 보고 말할래요\n(Te miraré a los ojos y te lo diré)", start: 91, end: 95 },
            { text: "보고 싶었어요\n(Te he extrañado)", start: 95.5, end: 96.5 },
            { text: "황홀했던 기억 속에\n(En los recuerdos encantadores)", start: 96.5, end: 102.5 },
            { text: "나 홀로 춤을 춰도 비가 내리잖아\n(Aunque baile solo, sigue lloviendo)", start: 103, end: 107 },
            { text: "이 안개가 걷힐 때쯤\n(Cuando esta niebla se levante)", start: 108, end: 112 },
            { text: "젖은 발로 달려갈게\n(Correré hacia ti con mis pies mojados)", start: 113, end: 117 },
            { text: "그때 날 안아줘\n(Abrázame entonces)", start: 118, end: 122 },
            { text: "저 달이 외로워 보여서\n(Porque la luna parecía solitaria)", start: 123, end: 128 },
            { text: "밤하늘에 환하게 울고 있는 것 같아서\n(Parecía llorar brillantemente en el cielo nocturno)", start: 128, end: 135 },
            { text: "언젠가 아침이 오는 걸 알면서도\n(Sabiendo que algún día llegaría la mañana)", start: 135, end: 140 },
            { text: "별처럼 너의 하늘에 머물고 싶었어\n(Quería quedarme en tu cielo como una estrella)", start: 140, end: 144 },
            { text: "하루를 그 순간을\n(Ese día, ese momento)", start: 144, end: 149 },
            { text: "이렇게 될 걸 알았다면\n(Si hubiera sabido que sería así)", start: 150, end: 154 },
            { text: "더 담아뒀을 텐데\n(Los habría guardado más en mis recuerdos)", start: 155, end: 160 },
            { text: "언제쯤일까\n(¿Cuándo será?)", start: 161, end: 165 },
            { text: "다시 그댈 마주한다면\n(Cuando te vuelva a ver)", start: 166, end: 170 },
            { text: "눈을 보고 말할래요\n(Te miraré a los ojos y te lo diré)", start: 171, end: 174 },
            { text: "보고 싶었어요\n(Te he extrañado)", start: 175, end: 179 },
            { text: "황홀했던 기억 속에\n(En los recuerdos encantadores)", start: 180, end: 185 },
            { text: "나 홀로 춤을 춰도 비가 내리잖아\n(Aunque baile solo, sigue lloviendo)", start: 186, end: 190 },
            { text: "이 안개가 걷힐 때쯤\n(Cuando esta niebla se levante)", start: 191, end: 195 },
            { text: "젖은 발로 달려갈게\n(Correré hacia ti con mis pies mojados)", start: 196, end: 200 },
            { text: "그때 날 안아줘\n(Abrázame entonces)", start: 201, end: 205 },
            { text: "♪ ♪ ♪ ♪ ♪ ♪", start: 205, end: 206 },
            { text: "날 바라보는 희미한 미소 뒤편에\n(Detrás de tu tenue sonrisa al mirarme)", start: 206, end: 211 },
            { text: "아름다운 보랏빛을 그려볼래요\n(Quiero pintar un hermoso color púrpura)", start: 215, end: 220 },
            { text: "서로 발걸음이 안 맞을 수도 있지만\n(Aunque nuestros pasos no coincidan)", start: 220, end: 226 },
            { text: "그대와 함께 이 길을 걷고 싶어요\n(Quiero caminar este camino contigo)", start: 226, end: 231 },
            { text: "Still With You\n(Aún contigo)", start: 232, end: 235 }
        ];
        class Particle {
            constructor(x, y, color = "white") {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 50;
                this.vy = (Math.random() - 0.5) * 50;
                this.life = 0;
                this.maxLife = 0.5 + Math.random() * 0.5;
                this.size = 1 + Math.random();
                this.color = color;
            }
            update(dt) {
                this.life += dt;
                this.x += this.vx * dt;
                this.y += this.vy * dt;
            }
            draw(ctx) {
                const alpha = 1 - (this.life / this.maxLife);
                if (alpha <= 0) return;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
            get dead() {
                return this.life >= this.maxLife;
            }
        }
        let starCounter = 0;
        class ShootingStar {
            constructor(x, y, special = false) {
                this.x = x ?? Math.random() * cw * 0.6;
                this.y = y ?? Math.random() * ch * 0.3;
                this.len = 80 + Math.random() * 100;
                this.speed = 250 + Math.random() * 250;
                this.angle = (Math.PI / 4) + (Math.random() - 0.5) * 0.25;
                this.life = 0;
                this.maxLife = 0.8 + Math.random() * 0.5;
                this.opacity = 1;
                this.special = special;
            }
            update(dt) {
                this.life += dt;
                this.x += Math.cos(this.angle) * this.speed * dt;
                this.y += Math.sin(this.angle) * this.speed * dt;
                this.opacity = 1 - (this.life / this.maxLife);
                if (Math.random() < 0.1) {
                    particles.push(new Particle(this.x, this.y, this.special ? this.rainbowColor() : "white"));
                }
            }
            rainbowColor() {
                const hue = (Date.now() / 20) % 360;
                return `hsl(${hue}, 100%, 70%)`;
            }
            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = Math.max(0, this.opacity);
                const grad = ctx.createLinearGradient(
                    this.x,
                    this.y,
                    this.x - Math.cos(this.angle) * this.len,
                    this.y - Math.sin(this.angle) * this.len
                );
                grad.addColorStop(0, this.special ? this.rainbowColor() : "rgba(255,255,255,1)");
                grad.addColorStop(1, "transparent");
                ctx.strokeStyle = grad;
                ctx.lineWidth = 1.5;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.special ? this.rainbowColor() : "white";
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x - Math.cos(this.angle) * this.len, this.y - Math.sin(this.angle) * this.len);
                ctx.stroke();
                ctx.restore();
            }
            get dead() {
                return this.life >= this.maxLife;
            }
        }
        class Flower {
            constructor(angle, height, size, swayPhase) {
                this.angle = angle;
                this.height = height;
                this.size = size;
                this.swayPhase = swayPhase;
                this.growth = 0;
                this.growthSpeed = 0.5 + Math.random() * 0.4;
                this.exploding = false;
                this.explosionScale = 1;
                this.opacity = 1;
                this.regrowDelay = 0;
            }
            update(dt) {
                if (this.regrowDelay > 0) {
                    this.regrowDelay = Math.max(0, this.regrowDelay - dt);
                    return;
                }
                if (!this.exploding && this.growth < 1) {
                    this.growth = Math.min(1, this.growth + this.growthSpeed * dt);
                }
                if (this.exploding) {
                    this.explosionScale += dt * 4.5;
                    this.opacity -= dt * 1.2;
                    if (this.opacity <= 0) {
                        this.exploding = false;
                        this.opacity = 1;
                        this.explosionScale = 1;
                        this.growth = 0;
                        this.regrowDelay = 0.6 + Math.random() * 0.8;
                        this.growthSpeed = 0.5 + Math.random() * 0.4;
                    }
                }
            }
            draw(ctx, baseX, baseY, sway) {
                const t = this.growth;
                if (t <= 0 && !this.exploding) return;
                const radius = this.height * t;
                const swayOffset = Math.sin(sway + this.swayPhase) * 10;
                const topX = baseX + Math.cos(this.angle) * radius + swayOffset;
                const topY = baseY - Math.sin(this.angle) * radius;
                ctx.save();
                ctx.lineWidth = 6;
                const gradStem = ctx.createLinearGradient(baseX, baseY, topX, topY);
                gradStem.addColorStop(0, colors.stemLight);
                gradStem.addColorStop(0.5, colors.stemDark);
                gradStem.addColorStop(1, "#061606");
                ctx.strokeStyle = gradStem;
                ctx.beginPath();
                ctx.moveTo(baseX, baseY);
                ctx.lineTo(topX, topY);
                ctx.stroke();
                ctx.restore();
                ctx.save();
                ctx.fillStyle = colors.leafMid;
                ctx.globalAlpha = 0.9;
                ctx.beginPath();
                ctx.ellipse(baseX + (topX - baseX) * 0.5 - 20, baseY + (topY - baseY) * 0.5, 25 * t, 12 * t, Math.PI / 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(baseX + (topX - baseX) * 0.5 + 20, baseY + (topY - baseY) * 0.5, 25 * t, 12 * t, -Math.PI / 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                if (t > 0.1 || this.exploding) {
                    ctx.save();
                    ctx.globalAlpha = this.opacity;
                    ctx.translate(topX, topY);
                    ctx.scale(this.explosionScale, this.explosionScale);
                    const flowerSize = this.size * Math.max(0.5, t);
                    for (let i = 0; i < 8; i++) {
                        ctx.save();
                        ctx.rotate((i * Math.PI) / 4);
                        const petalGrad = ctx.createRadialGradient(0, -flowerSize * 0.7, 2, 0, -flowerSize * 0.7, flowerSize);
                        petalGrad.addColorStop(0, colors.petalLight);
                        petalGrad.addColorStop(0.6, colors.petalMid);
                        petalGrad.addColorStop(1, colors.petalDark);
                        ctx.beginPath();
                        ctx.ellipse(0, -flowerSize * 0.7, flowerSize * 0.3, flowerSize * 0.7, 0, 0, Math.PI * 2);
                        ctx.fillStyle = petalGrad;
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = colors.glow;
                        ctx.fill();
                        ctx.restore();
                    }
                    const r = flowerSize * 0.4;
                    const g = ctx.createRadialGradient(0, 0, r * 0.2, 0, 0, r);
                    g.addColorStop(0, colors.center1);
                    g.addColorStop(0.7, colors.center2);
                    g.addColorStop(1, "#2a1500");
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.fillStyle = g;
                    ctx.fill();
                    ctx.restore();
                }
            }
            isClicked(x, y, baseX, baseY, sway) {
                const t = this.growth;
                const radius = this.height * t;
                const swayOffset = Math.sin(sway + this.swayPhase) * 10;
                const topX = baseX + Math.cos(this.angle) * radius + swayOffset;
                const topY = baseY - Math.sin(this.angle) * radius;
                const dist = Math.hypot(x - topX, y - topY);
                return dist < this.size * 1.5;
            }
        }
        function createStars() {
            stars.length = 0;
            for (let i = 0; i < STAR_COUNT; i++) {
                stars.push({
                    x: Math.random() * cw,
                    y: Math.random() * ch,
                    r: Math.random() * 0.8,
                    alpha: 0.25 + Math.random() * 0.75
                });
            }
        }
        function initFlowers() {
            flowers.length = 0;
            const spread = Math.PI / 2.2;
            const startAngle = (Math.PI / 2) - (spread / 2);
            for (let i = 0; i < FLOWER_COUNT; i++) {
                const angle = startAngle + (i / (FLOWER_COUNT - 1)) * spread;
                const h = 200 + Math.random() * 80;
                const s = 30 + Math.random() * 10;
                const swayPhase = Math.random() * Math.PI * 2;
                flowers.push(new Flower(angle, h, s, swayPhase));
            }
        }
        function resize() {
            cw = window.innerWidth;
            ch = window.innerHeight;
            canvas.style.width = cw + "px";
            canvas.style.height = ch + "px";
            canvas.width = Math.floor(cw * dpr);
            canvas.height = Math.floor(ch * dpr);
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            baseX = cw / 2;
            baseY = ch;
            createStars();
            shootingStars = Array.from({ length: SHOOTING_STAR_COUNT }, () => new ShootingStar());
            initFlowers();
        }
        resize();
        window.addEventListener("resize", resize);
        canvas.addEventListener("click", (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const sway = swayTime;
            for (const f of flowers) {
                if (f.isClicked(mouseX, mouseY, baseX, baseY, sway)) {
                    f.exploding = true;
                    f.explosionScale = 1;
                    f.opacity = 1;
                    for (let i = 0; i < PARTICLE_CLICK_COUNT; i++) {
                        particles.push(new Particle(baseX + Math.cos(f.angle) * f.height, baseY - Math.sin(f.angle) * f.height, colors.petalLight));
                    }
                }
            }
        });
        canvas.addEventListener("mousemove", (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            if (Math.random() < PARTICLE_MOUSE_COUNT) {
                particles.push(new Particle(x, y, "rgba(200,200,255,0.9)"));
            }
        });
        function autoShootingStar() {
            const cantidad = 1;
            for (let i = 0; i < cantidad; i++) {
                starCounter++;
                const special = starCounter % 5 === 0;
                shootingStars.push(new ShootingStar(undefined, undefined, special));
            }
            const delay = 1000 + Math.random() * 1000;
            setTimeout(autoShootingStar, delay);
        }
        autoShootingStar();
        let lastTime = performance.now();
        let swayTime = 0;
        let currentSubtitleIndex = -1;
        function animate(now) {
            let dt = (now - lastTime) / 1000;
            lastTime = now;
            if (dt > 0.05) dt = 0.05;
            swayTime += dt;
            const currentTime = audio.currentTime;
            let foundSubtitle = false;
            for (let i = 0; i < lyricsData.length; i++) {
                if (currentTime >= lyricsData[i].start && currentTime < lyricsData[i].end) {
                    if (currentSubtitleIndex !== i) {
                        subtitlesDiv.textContent = lyricsData[i].text;
                        subtitlesDiv.classList.add('active');
                        currentSubtitleIndex = i;
                    }
                    foundSubtitle = true;
                    break;
                }
            }
            if (!foundSubtitle && subtitlesDiv.classList.contains('active')) {
                subtitlesDiv.classList.remove('active');
                subtitlesDiv.textContent = '';
                currentSubtitleIndex = -1;
            }
            const grad = ctx.createLinearGradient(0, 0, 0, ch);
            grad.addColorStop(0, colors.sky1);
            grad.addColorStop(0.25, colors.sky2);
            grad.addColorStop(0.5, colors.sky3);
            grad.addColorStop(0.75, colors.sky4);
            grad.addColorStop(1, colors.horizon);
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, cw, ch);
            ctx.globalAlpha = 1;
            ctx.fillStyle = "white";
            for (const s of stars) {
                ctx.globalAlpha = s.alpha;
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
            shootingStars = shootingStars.filter(s => {
                s.update(dt);
                s.draw(ctx);
                return !s.dead;
            });
            particles = particles.filter(p => {
                p.update(dt);
                p.draw(ctx);
                return !p.dead;
            });
            const sway = swayTime * 1.6;
            for (const f of flowers) {
                f.update(dt);
                f.draw(ctx, baseX, baseY, sway);
            }
            requestAnimationFrame(animate);
        }
        requestAnimationFrame(animate);
        document.addEventListener('click', () => {
            if (audio.paused) {
                audio.play();
            }
        }, { once: true });
    </script>
</body>
</html>
