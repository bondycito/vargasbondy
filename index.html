<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Abanico de girasoles - Optimizado</title>
    <style>
        * { margin:0; padding:0; box-sizing:border-box; }
        html, body { height:100%; }
        body { background: black; overflow: hidden; }
        canvas { display:block; width:100%; height:100vh; cursor: crosshair; }
        
        #subtitles {
            position: absolute;
            top: 5%;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            text-align: center;
            color: #fff799;
            font-family: sans-serif;
            font-size: 1.2rem; /* Tamaño de fuente más pequeño para móviles */
            text-shadow: 1px 1px 2px #000; /* Sombra más ligera */
            z-index: 10;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }
        
        #subtitles.active {
            opacity: 1;
        }
    </style>
</head>
<body>
    <canvas id="scene"></canvas>
    <audio id="background-music" src="musica.mp3" loop></audio>
    <div id="subtitles"></div>

    <script>
        const canvas = document.getElementById("scene");
        const ctx = canvas.getContext("2d"); // No es necesario { alpha: false } si el fondo ya es negro
        const audio = document.getElementById("background-music");
        const subtitlesDiv = document.getElementById("subtitles");

        // Optimización: Reducir la resolución interna del canvas para menos píxeles a renderizar
        const dpr = Math.min(1.5, window.devicePixelRatio || 1); 

        let cw = window.innerWidth;
        let ch = window.innerHeight;
        let baseX, baseY;

        // Optimización: Reducir la cantidad de estrellas y elementos
        const STAR_COUNT = 100;
        const SHOOTING_STAR_COUNT = 1;
        const FLOWER_COUNT = 4;
        const PARTICLE_CLICK_COUNT = 10;
        const PARTICLE_MOUSE_COUNT = 1; // Reducido para evitar lag al mover el mouse

        const stars = [];
        let shootingStars = [];
        let particles = [];
        const flowers = [];

        const colors = {
            sky1: "#0a0220", sky2: "#120a40",
            sky3: "#1b1035", sky4: "#241a2e",
            horizon: "#3a1d1d",
            stemLight: "#3ba55d", stemDark: "#0a1f0a",
            leafBright: "#4caf50", leafMid: "#2e7d32", leafDark: "#0a2f12",
            petalLight: "#fff799", petalMid: "#ffe066", petalDark: "#ffcc00",
            center1: "#e6b53a", center2: "#5a3a00",
            glow: "rgba(255,255,200,0.95)"
        };

        const lyricsData = [
            { text: "날 스치는 그대의 옅은 그 목소리\n(Tu voz tenue que me roza)", start: 0.0, end: 4.0 },
            { text: "내 이름을 한 번만 더 불러주세요\n(Por favor, llama mi nombre una vez más)", start: 4.5, end: 8.5 },
            // ... (resto de los datos)
        ];

        // --- Utilidades ---
        function createStars() {
            stars.length = 0;
            for (let i = 0; i < STAR_COUNT; i++) {
                stars.push({
                    x: Math.random() * cw,
                    y: Math.random() * ch,
                    r: Math.random() * 0.8, // Radios más pequeños
                    alpha: 0.25 + Math.random() * 0.75
                });
            }
        }

        // --- Partículas chispeantes ---
        class Particle {
            constructor(x, y, color = "white") {
                this.x = x;
                this.y = y;
                // Optimización: Velocidades más bajas para menos movimiento
                this.vx = (Math.random() - 0.5) * 50; 
                this.vy = (Math.random() - 0.5) * 50;
                this.life = 0;
                this.maxLife = 0.5 + Math.random() * 0.5;
                this.size = 1 + Math.random(); // Tamaño más pequeño
                this.color = color;
            }
            update(dt) {
                this.life += dt;
                this.x += this.vx * dt;
                this.y += this.vy * dt;
            }
            draw(ctx) {
                const alpha = 1 - (this.life / this.maxLife);
                if (alpha <= 0) return;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
            get dead() { return this.life >= this.maxLife; }
        }

        // --- Estrella fugaz ---
        let starCounter = 0;
        class ShootingStar {
            constructor(x, y, special = false) {
                this.x = x ?? Math.random() * cw * 0.6;
                this.y = y ?? Math.random() * ch * 0.3;
                this.len = 80 + Math.random() * 100; // Longitud más corta
                this.speed = 250 + Math.random() * 250; // Velocidad más baja
                this.angle = (Math.PI / 4) + (Math.random() - 0.5) * 0.25;
                this.life = 0;
                this.maxLife = 0.8 + Math.random() * 0.5;
                this.opacity = 1;
                this.special = special;
            }
            update(dt) {
                this.life += dt;
                this.x += Math.cos(this.angle) * this.speed * dt;
                this.y += Math.sin(this.angle) * this.speed * dt;
                this.opacity = 1 - (this.life / this.maxLife);
                // Optimización: Reducir la creación de partículas
                if (Math.random() < 0.1) {
                    particles.push(new Particle(this.x, this.y, this.special ? this.rainbowColor() : "white"));
                }
            }
            rainbowColor() {
                const hue = (Date.now() / 20) % 360;
                return `hsl(${hue}, 100%, 70%)`;
            }
            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = Math.max(0, this.opacity);
                const grad = ctx.createLinearGradient(
                    this.x, this.y,
                    this.x - Math.cos(this.angle) * this.len,
                    this.y - Math.sin(this.angle) * this.len
                );
                grad.addColorStop(0, this.special ? this.rainbowColor() : "rgba(255,255,255,1)");
                grad.addColorStop(1, "transparent");
                ctx.strokeStyle = grad;
                ctx.lineWidth = 1.5; // Grosor de línea más delgado
                ctx.shadowBlur = 10; // Sombra más suave
                ctx.shadowColor = this.special ? this.rainbowColor() : "white";
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x - Math.cos(this.angle) * this.len, this.y - Math.sin(this.angle) * this.len);
                ctx.stroke();
                ctx.restore();
            }
            get dead() { return this.life >= this.maxLife; }
        }

        // --- Flor con tallo y hojas ---
        class Flower {
            constructor(angle, height, size) {
                this.angle = angle;
                this.height = height;
                this.size = size;
                this.growth = 0;
                this.growthSpeed = 0.5 + Math.random() * 0.4;
                this.exploding = false;
                this.explosionScale = 1;
                this.opacity = 1;
                this.regrowDelay = 0;
            }
            update(dt) {
                if (this.regrowDelay > 0) {
                    this.regrowDelay = Math.max(0, this.regrowDelay - dt);
                    return;
                }
                if (!this.exploding && this.growth < 1) {
                    this.growth = Math.min(1, this.growth + this.growthSpeed * dt);
                }
                if (this.exploding) {
                    this.explosionScale += dt * 4.5;
                    this.opacity -= dt * 1.2;
                    if (this.opacity <= 0) {
                        this.exploding = false;
                        this.opacity = 1;
                        this.explosionScale = 1;
                        this.growth = 0;
                        this.regrowDelay = 0.6 + Math.random() * 0.8;
                        this.growthSpeed = 0.5 + Math.random() * 0.4;
                    }
                }
            }
            draw(ctx, baseX, baseY, sway) {
                const t = this.growth;
                if (t <= 0 && !this.exploding) return;

                const radius = this.height * t;
                const swayOffset = Math.sin(sway + this.angle) * 10; // Movimiento más sutil
                const topX = baseX + Math.cos(this.angle) * radius + swayOffset;
                const topY = baseY - Math.sin(this.angle) * radius;

                ctx.save();
                ctx.lineWidth = 6; // Tallo más delgado
                const gradStem = ctx.createLinearGradient(baseX, baseY, topX, topY);
                gradStem.addColorStop(0, colors.stemLight);
                gradStem.addColorStop(0.5, colors.stemDark);
                gradStem.addColorStop(1, "#061606");
                ctx.strokeStyle = gradStem;
                ctx.beginPath();
                ctx.moveTo(baseX, baseY);
                ctx.lineTo(topX, topY);
                ctx.stroke();

                // Optimización: Dibujar hojas de forma simplificada
                ctx.fillStyle = colors.leafMid;
                ctx.globalAlpha = 0.9;
                ctx.beginPath();
                ctx.ellipse((baseX + topX) / 2 - 20, (baseY + topY) / 2, 25 * t, 12 * t, Math.PI / 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse((baseX + topX) / 2 + 20, (baseY + topY) / 2, 25 * t, 12 * t, -Math.PI / 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                if (t > 0.1 || this.exploding) {
                    ctx.save();
                    ctx.globalAlpha = this.opacity;
                    ctx.translate(topX, topY);
                    ctx.scale(this.explosionScale, this.explosionScale);

                    const flowerSize = this.size * Math.max(0.5, t);
                    // Optimización: Reducir el número de pétalos
                    for (let i = 0; i < 8; i++) {
                        ctx.save();
                        ctx.rotate((i * Math.PI) / 4);
                        const petalGrad = ctx.createRadialGradient(0, -flowerSize * 0.7, 2, 0, -flowerSize * 0.7, flowerSize);
                        petalGrad.addColorStop(0, colors.petalLight);
                        petalGrad.addColorStop(0.6, colors.petalMid);
                        petalGrad.addColorStop(1, colors.petalDark);
                        ctx.beginPath();
                        ctx.ellipse(0, -flowerSize * 0.7, flowerSize * 0.3, flowerSize * 0.7, 0, 0, Math.PI * 2);
                        ctx.fillStyle = petalGrad;
                        ctx.shadowBlur = 15; // Sombra más ligera
                        ctx.shadowColor = colors.glow;
                        ctx.fill();
                        ctx.restore();
                    }
                    const r = flowerSize * 0.4; // Centro más pequeño
                    const g = ctx.createRadialGradient(0, 0, r * 0.2, 0, 0, r);
                    g.addColorStop(0, colors.center1);
                    g.addColorStop(0.7, colors.center2);
                    g.addColorStop(1, "#2a1500");
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.fillStyle = g;
                    ctx.fill();
                    ctx.restore();
                }
            }

            isClicked(x, y, baseX, baseY, sway) {
                const t = this.growth;
                const radius = this.height * t;
                const swayOffset = Math.sin(sway + this.angle) * 10;
                const topX = baseX + Math.cos(this.angle) * radius + swayOffset;
                const topY = baseY - Math.sin(this.angle) * radius;
                const dist = Math.hypot(x - topX, y - topY);
                return dist < this.size * 1.5; // Área de clic más pequeña
            }
        }

        // --- Inicialización ---
        function initFlowers() {
            flowers.length = 0;
            const spread = Math.PI / 2;
            for (let i = 0; i < FLOWER_COUNT; i++) {
                const angle = Math.PI / 4 + (i / (FLOWER_COUNT - 1)) * spread;
                const extraHeight = (i % 2 === 0) ? 80 : 0; // Menos diferencia de altura
                const h = 200 + Math.random() * 50 + extraHeight;
                const s = 30 + Math.random() * 10;
                flowers.push(new Flower(angle, h, s));
            }
        }

        function resize() {
            cw = window.innerWidth;
            ch = window.innerHeight;
            canvas.style.width = cw + "px";
            canvas.style.height = ch + "px";
            canvas.width = Math.floor(cw * dpr);
            canvas.height = Math.floor(ch * dpr);
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            baseX = cw / 2;
            baseY = ch;
            createStars();
            shootingStars = Array.from({ length: SHOOTING_STAR_COUNT }, () => new ShootingStar());
            initFlowers();
        }
        resize();
        window.addEventListener("resize", resize);

        // --- Interacciones ---
        canvas.addEventListener("click", (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const sway = swayTime;
            for (const f of flowers) {
                if (f.isClicked(mouseX, mouseY, baseX, baseY, sway)) {
                    f.exploding = true;
                    f.explosionScale = 1;
                    f.opacity = 1;
                    // Añadir menos partículas al explotar
                    for (let i = 0; i < PARTICLE_CLICK_COUNT; i++) {
                        particles.push(new Particle(baseX + Math.cos(f.angle) * f.height, baseY - Math.sin(f.angle) * f.height, colors.petalLight));
                    }
                }
            }
            starCounter++;
            const special = starCounter % 5 === 0; // Más estrellas especiales
            shootingStars.push(new ShootingStar(mouseX, mouseY, special));
        });

        canvas.addEventListener("mousemove", (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            // Optimización: Menos partículas con cada movimiento del mouse
            if (Math.random() < 0.2) {
                particles.push(new Particle(x, y, "rgba(200,200,255,0.9)"));
            }
        });

        // --- Generar estrellas fugaces automáticamente ---
        function autoShootingStar() {
            const cantidad = 1;
            for (let i = 0; i < cantidad; i++) {
                starCounter++;
                const special = starCounter % 5 === 0;
                shootingStars.push(new ShootingStar(undefined, undefined, special));
            }
            const delay = 600 + Math.random() * 800; // Intervalo más largo
            setTimeout(autoShootingStar, delay);
        }
        autoShootingStar();

        // --- Animación ---
        let lastTime = performance.now();
        let swayTime = 0;
        let currentSubtitleIndex = -1;

        function animate(now) {
            let dt = (now - lastTime) / 1000;
            lastTime = now;
            // Limitar dt para evitar saltos en la animación con lag
            if (dt > 0.05) dt = 0.05; 
            swayTime += dt;

            // ... (el código de los subtítulos es el mismo)
            const currentTime = audio.currentTime;
            let foundSubtitle = false;
            for(let i = 0; i < lyricsData.length; i++) {
                if(currentTime >= lyricsData[i].start && currentTime < lyricsData[i].end) {
                    if(currentSubtitleIndex !== i) {
                        subtitlesDiv.textContent = lyricsData[i].text;
                        subtitlesDiv.classList.add('active');
                        currentSubtitleIndex = i;
                    }
                    foundSubtitle = true;
                    break;
                }
            }
            if (!foundSubtitle && subtitlesDiv.classList.contains('active')) {
                subtitlesDiv.classList.remove('active');
                subtitlesDiv.textContent = '';
                currentSubtitleIndex = -1;
            }

            // Dibuja el fondo, estrellas, estrellas fugaces y flores
            const grad = ctx.createLinearGradient(0, 0, 0, ch);
            grad.addColorStop(0, colors.sky1);
            grad.addColorStop(0.25, colors.sky2);
            grad.addColorStop(0.5, colors.sky3);
            grad.addColorStop(0.75, colors.sky4);
            grad.addColorStop(1, colors.horizon);
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, cw, ch);

            ctx.globalAlpha = 1;
            ctx.fillStyle = "white";
            for (const s of stars) {
                ctx.globalAlpha = s.alpha;
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            // Optimización: solo actualiza si hay elementos
            if (shootingStars.length > 0) {
                shootingStars.forEach(s => { s.update(dt); s.draw(ctx); });
                shootingStars = shootingStars.filter(s => !s.dead);
            }

            if (particles.length > 0) {
                particles.forEach(p => { p.update(dt); p.draw(ctx); });
                particles = particles.filter(p => !p.dead);
            }
            
            const sway = swayTime * 1.6;
            for (const f of flowers) {
                f.update(dt);
                f.draw(ctx, baseX, baseY, sway);
            }

            requestAnimationFrame(animate);
        }
        requestAnimationFrame(animate);

        document.addEventListener('click', () => {
            if (audio.paused) {
                audio.play();
            }
        }, { once: true });
    </script>
</body>
</html>
