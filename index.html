<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
    <title>Abanico de girasoles con tallos, hojas y muchas estrellas fugaces</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; }
        body { background: black; overflow: hidden; }
        canvas { display: block; width: 100%; height: 100vh; cursor: crosshair; touch-action: none; }
        
        /* Estilos para los subtítulos personalizados */
        #subtitles {
            position: absolute;
            top: 5%;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            text-align: center;
            color: #fff799;
            font-family: sans-serif;
            font-size: clamp(1rem, 3.5vw, 1.8rem); /* Escala el tamaño de fuente */
            text-shadow: 2px 2px 4px #000;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }
        
        #subtitles.active {
            opacity: 1;
        }

        /* Ajustes para pantallas pequeñas */
        @media (max-width: 600px) {
            #subtitles {
                top: 10%;
                font-size: clamp(0.8rem, 4vw, 1.2rem);
            }
        }
    </style>
</head>
<body>
    <canvas id="scene"></canvas>
    <audio id="background-music" src="musica.mp3" loop></audio>
    <div id="subtitles"></div>

    <script>
        const canvas = document.getElementById("scene");
        const ctx = canvas.getContext("2d", { alpha: false });
        const audio = document.getElementById("background-music");
        const subtitlesDiv = document.getElementById("subtitles");

        let cw = window.innerWidth;
        let ch = window.innerHeight;
        const dpr = Math.min(window.devicePixelRatio || 1, 2); // Limita DPR para móviles

        let baseX = cw / 2;
        let baseY = ch;

        const stars = [];
        let shootingStars = [];
        let particles = [];
        const flowers = [];

        const colors = {
            sky1: "#0a0220", sky2: "#120a40",
            sky3: "#1b1035", sky4: "#241a2e",
            horizon: "#3a1d1d",
            stemLight: "#3ba55d", stemDark: "#0a1f0a",
            leafBright: "#4caf50", leafMid: "#2e7d32", leafDark: "#0a2f12",
            petalLight: "#fff799", petalMid: "#ffe066", petalDark: "#ffcc00",
            center1: "#e6b53a", center2: "#5a3a00",
            glow: "rgba(255,255,200,0.95)"
        };

        // Datos de subtítulos
        const lyricsData = [
            { text: "날 스치는 그대의 옅은 그 목소리\n(Tu voz tenue que me roza)", start: 0.0, end: 4.0 },
            // ... (resto de los subtítulos, omitidos por brevedad) ...
        ];

        // --- Utilidades ---
        function createStars(count = Math.min(220, Math.floor(cw * ch / 5000))) { // Reducir estrellas en móviles
            stars.length = 0;
            for (let i = 0; i < count; i++) {
                stars.push({
                    x: Math.random() * cw,
                    y: Math.random() * ch,
                    r: Math.random() * (cw < 600 ? 0.8 : 1.2),
                    alpha: 0.25 + Math.random() * 0.75
                });
            }
        }

        // --- Partículas chispeantes ---
        class Particle {
            constructor(x, y, color = "white") {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * (cw < 600 ? 60 : 100);
                this.vy = (Math.random() - 0.5) * (cw < 600 ? 60 : 100);
                this.life = 0;
                this.maxLife = 0.6 + Math.random() * 0.6;
                this.size = (cw < 600 ? 0.8 : 1) + Math.random() * (cw < 600 ? 1.5 : 2);
                this.color = color;
            }
            update(dt) {
                this.life += dt;
                this.x += this.vx * dt;
                this.y += this.vy * dt;
            }
            draw(ctx) {
                const alpha = 1 - (this.life / this.maxLife);
                if (alpha <= 0) return;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
            get dead() { return this.life >= this.maxLife; }
        }

        // --- Estrella fugaz ---
        let starCounter = 0;
        class ShootingStar {
            constructor(x, y, special = false) {
                this.x = x ?? Math.random() * cw * 0.6;
                this.y = y ?? Math.random() * ch * 0.3;
                this.len = (cw < 600 ? 60 : 100) + Math.random() * (cw < 600 ? 80 : 140);
                this.speed = (cw < 600 ? 300 : 400) + Math.random() * (cw < 600 ? 300 : 400);
                this.angle = (Math.PI / 4) + (Math.random() - 0.5) * 0.25;
                this.life = 0;
                this.maxLife = 0.8 + Math.random() * 0.7;
                this.opacity = 1;
                this.special = special;
            }
            update(dt) {
                this.life += dt;
                this.x += Math.cos(this.angle) * this.speed * dt;
                this.y += Math.sin(this.angle) * this.speed * dt;
                this.opacity = 1 - (this.life / this.maxLife);
                if (Math.random() < (cw < 600 ? 0.2 : 0.3)) {
                    particles.push(new Particle(this.x, this.y, this.special ? this.rainbowColor() : "white"));
                }
            }
            rainbowColor() {
                const hue = (Date.now() / 20) % 360;
                return `hsl(${hue}, 100%, 70%)`;
            }
            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = Math.max(0, this.opacity);
                const grad = ctx.createLinearGradient(
                    this.x, this.y,
                    this.x - Math.cos(this.angle) * this.len,
                    this.y - Math.sin(this.angle) * this.len
                );
                grad.addColorStop(0, this.special ? this.rainbowColor() : "rgba(255,255,255,1)");
                grad.addColorStop(1, "transparent");
                ctx.strokeStyle = grad;
                ctx.lineWidth = cw < 600 ? 1.5 : 2.5;
                ctx.shadowBlur = cw < 600 ? 10 : 20;
                ctx.shadowColor = this.special ? this.rainbowColor() : "white";
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x - Math.cos(this.angle) * this.len, this.y - Math.sin(this.angle) * this.len);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(this.x, this.y, cw < 600 ? 10 : 15, 0, Math.PI * 2);
                ctx.fillStyle = grad;
                ctx.fill();
                ctx.restore();
            }
            get dead() { return this.life >= this.maxLife; }
        }

        // --- Flor con tallo y hojas ---
        class Flower {
            constructor(angle, height, size) {
                this.angle = angle;
                this.height = height * (cw < 600 ? 0.7 : 1); // Reducir altura en móviles
                this.size = size * (cw < 600 ? 0.7 : 1); // Reducir tamaño en móviles
                this.growth = 0;
                this.growthSpeed = 0.45 + Math.random() * 0.3;
                this.exploding = false;
                this.explosionScale = 1;
                this.opacity = 1;
                this.regrowDelay = 0;
            }
            update(dt) {
                if (this.regrowDelay > 0) {
                    this.regrowDelay = Math.max(0, this.regrowDelay - dt);
                    return;
                }
                if (!this.exploding && this.growth < 1) {
                    this.growth = Math.min(1, this.growth + this.growthSpeed * dt);
                }
                if (this.exploding) {
                    this.explosionScale += dt * 4.5;
                    this.opacity -= dt * 1.2;
                    if (this.opacity <= 0) {
                        this.exploding = false;
                        this.opacity = 1;
                        this.explosionScale = 1;
                        this.growth = 0;
                        this.regrowDelay = 0.6 + Math.random() * 0.8;
                        this.growthSpeed = 0.45 + Math.random() * 0.35;
                    }
                }
            }
            draw(ctx, baseX, baseY, sway) {
                const t = this.growth;
                if (t <= 0 && !this.exploding) return;

                const radius = this.height * t;
                const swayOffset = Math.sin(sway + this.angle) * (cw < 600 ? 10 : 20);
                const topX = baseX + Math.cos(this.angle) * radius + swayOffset;
                const topY = baseY - Math.sin(this.angle) * radius;

                // Tallo
                ctx.save();
                ctx.lineWidth = cw < 600 ? 6 : 10;
                const gradStem = ctx.createLinearGradient(baseX, baseY, topX, topY);
                gradStem.addColorStop(0, colors.stemLight);
                gradStem.addColorStop(0.5, colors.stemDark);
                gradStem.addColorStop(1, "#061606");
                ctx.strokeStyle = gradStem;
                ctx.beginPath();
                ctx.moveTo(baseX, baseY);
                ctx.lineTo(topX, topY);
                ctx.stroke();

                // Hojas
                const leafGrad = ctx.createRadialGradient(0, 0, 5, 0, 0, cw < 600 ? 30 : 40);
                leafGrad.addColorStop(0, colors.leafBright);
                leafGrad.addColorStop(0.5, colors.leafMid);
                leafGrad.addColorStop(1, colors.leafDark);
                ctx.fillStyle = leafGrad;
                ctx.globalAlpha = 0.9;

                ctx.beginPath();
                ctx.ellipse((baseX + topX) / 2 - (cw < 600 ? 20 : 28), (baseY + topY) / 2, (cw < 600 ? 28 : 38) * t, (cw < 600 ? 12 : 18) * t, Math.PI / 3, 0, Math.PI * 2);
                ctx.shadowBlur = cw < 600 ? 10 : 15;
                ctx.shadowColor = "#1c4d1c";
                ctx.fill();

                ctx.beginPath();
                ctx.ellipse((baseX + topX) / 2 + (cw < 600 ? 20 : 28), (baseY + topY) / 2, (cw < 600 ? 28 : 38) * t, (cw < 600 ? 12 : 18) * t, -Math.PI / 3, 0, Math.PI * 2);
                ctx.shadowBlur = cw < 600 ? 10 : 15;
                ctx.shadowColor = "#1c4d1c";
                ctx.fill();
                ctx.restore();

                // Pétalos y centro
                if (t > 0.1 || this.exploding) {
                    ctx.save();
                    ctx.globalAlpha = this.opacity;
                    ctx.translate(topX, topY);
                    ctx.scale(this.explosionScale, this.explosionScale);

                    const flowerSize = this.size * Math.max(0.5, t);
                    for (let i = 0; i < 12; i++) {
                        ctx.save();
                        ctx.rotate((i * Math.PI) / 6);
                        const petalGrad = ctx.createRadialGradient(0, -flowerSize * 0.7, 2, 0, -flowerSize * 0.7, flowerSize);
                        petalGrad.addColorStop(0, colors.petalLight);
                        petalGrad.addColorStop(0.6, colors.petalMid);
                        petalGrad.addColorStop(1, colors.petalDark);
                        ctx.beginPath();
                        ctx.ellipse(0, -flowerSize * 0.7, flowerSize * 0.35, flowerSize * 0.8, 0, 0, Math.PI * 2);
                        ctx.fillStyle = petalGrad;
                        ctx.shadowBlur = cw < 600 ? 15 : 25;
                        ctx.shadowColor = colors.glow;
                        ctx.fill();
                        ctx.restore();
                    }
                    const r = flowerSize * 0.45;
                    const g = ctx.createRadialGradient(0, 0, r * 0.2, 0, 0, r);
                    g.addColorStop(0, colors.center1);
                    g.addColorStop(0.7, colors.center2);
                    g.addColorStop(1, "#2a1500");
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.fillStyle = g;
                    ctx.fill();
                    ctx.restore();
                }
            }
            isClicked(x, y, baseX, baseY, sway) {
                const t = this.growth;
                const radius = this.height * t;
                const swayOffset = Math.sin(sway + this.angle) * (cw < 600 ? 10 : 20);
                const topX = baseX + Math.cos(this.angle) * radius + swayOffset;
                const topY = baseY - Math.sin(this.angle) * radius;
                const dist = Math.hypot(x - topX, y - topY);
                return dist < this.size * 1.8;
            }
        }

        // --- Inicialización ---
        function initFlowers() {
            flowers.length = 0;
            const count = cw < 600 ? 4 : 6; // Menos flores en móviles
            const spread = Math.PI / 2;
            for (let i = 0; i < count; i++) {
                const angle = Math.PI / 4 + (i / (count - 1)) * spread;
                const extraHeight = (i % 2 === 0) ? (cw < 600 ? 80 : 120) : 0;
                const h = (cw < 600 ? 180 : 260) + Math.random() * (cw < 600 ? 60 : 80) + extraHeight;
                const s = (cw < 600 ? 35 : 45) + Math.random() * 20;
                flowers.push(new Flower(angle, h, s));
            }
        }

        function resize() {
            cw = window.innerWidth;
            ch = window.innerHeight;
            canvas.style.width = cw + "px";
            canvas.style.height = ch + "px";
            canvas.width = Math.floor(cw * dpr);
            canvas.height = Math.floor(ch * dpr);
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            baseX = cw / 2;
            baseY = ch;
            createStars();
            shootingStars = Array.from({ length: cw < 600 ? 2 : 3 }, () => new ShootingStar());
            initFlowers();
        }
        resize();
        window.addEventListener("resize", resize);

        // --- Interacciones ---
        function handleInteraction(x, y) {
            const sway = swayTime;
            for (const f of flowers) {
                if (f.isClicked(x, y, baseX, baseY, sway)) {
                    f.exploding = true;
                    f.explosionScale = 1;
                    f.opacity = 1;
                    for (let i = 0; i < (cw < 600 ? 10 : 20); i++) {
                        particles.push(new Particle(baseX + Math.cos(f.angle) * f.height, baseY - Math.sin(f.angle) * f.height, colors.petalLight));
                    }
                }
            }
            starCounter++;
            const special = starCounter % 10 === 0;
            shootingStars.push(new ShootingStar(x, y, special));
        }

        canvas.addEventListener("click", (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            handleInteraction(mouseX, mouseY);
        });

        canvas.addEventListener("touchstart", (e) => {
            e.preventDefault(); // Evitar desplazamiento
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const touchX = touch.clientX - rect.left;
            const touchY = touch.clientY - rect.top;
            handleInteraction(touchX, touchY);
        });

        canvas.addEventListener("mousemove", (e) => {
            if (cw >= 600) { // Solo en PC
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                particles.push(new Particle(x, y, "rgba(200,200,255,0.9)"));
            }
        });

        canvas.addEventListener("touchmove", (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            particles.push(new Particle(x, y, "rgba(200,200,255,0.9)"));
        });

        // --- Generar estrellas fugaces automáticamente ---
        function autoShootingStar() {
            const cantidad = cw < 600 ? 1 + Math.floor(Math.random() * 2) : 2 + Math.floor(Math.random() * 2);
            for (let i = 0; i < cantidad; i++) {
                starCounter++;
                const special = starCounter % 10 === 0;
                shootingStars.push(new ShootingStar(undefined, undefined, special));
            }
            const delay = (cw < 600 ? 500 : 300) + Math.random() * 400;
            setTimeout(autoShootingStar, delay);
        }
        autoShootingStar();

        // --- Animación ---
        let lastTime = performance.now();
        let swayTime = 0;
        let currentSubtitleIndex = -1;

        function animate(now) {
            let dt = (now - lastTime) / 1000;
            lastTime = now;
            if (dt > 0.05) dt = 0.05;
            swayTime += dt;

            // Subtítulos
            const currentTime = audio.currentTime;
            let foundSubtitle = false;
            for (let i = 0; i < lyricsData.length; i++) {
                if (currentTime >= lyricsData[i].start && currentTime < lyricsData[i].end) {
                    if (currentSubtitleIndex !== i) {
                        subtitlesDiv.textContent = lyricsData[i].text;
                        subtitlesDiv.classList.add('active');
                        currentSubtitleIndex = i;
                    }
                    foundSubtitle = true;
                    break;
                }
            }
            if (!foundSubtitle && subtitlesDiv.classList.contains('active')) {
                subtitlesDiv.classList.remove('active');
                subtitlesDiv.textContent = '';
                currentSubtitleIndex = -1;
            }

            const grad = ctx.createLinearGradient(0, 0, 0, ch);
            grad.addColorStop(0, colors.sky1);
            grad.addColorStop(0.25, colors.sky2);
            grad.addColorStop(0.5, colors.sky3);
            grad.addColorStop(0.75, colors.sky4);
            grad.addColorStop(1, colors.horizon);
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, cw, ch);

            ctx.globalAlpha = 1;
            ctx.fillStyle = "white";
            for (const s of stars) {
                ctx.globalAlpha = s.alpha;
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            shootingStars.forEach(s => { s.update(dt); s.draw(ctx); });
            shootingStars = shootingStars.filter(s => !s.dead);

            particles.forEach(p => { p.update(dt); p.draw(ctx); });
            particles = particles.filter(p => !p.dead);

            const sway = swayTime * 1.6;
            for (const f of flowers) {
                f.update(dt);
                f.draw(ctx, baseX, baseY, sway);
            }

            requestAnimationFrame(animate);
        }
        requestAnimationFrame(animate);

        document.addEventListener('click', () => {
            if (audio.paused) {
                audio.play().catch(err => console.log("Error playing audio:", err));
            }
        }, { once: true });

        document.addEventListener('touchstart', () => {
            if (audio.paused) {
                audio.play().catch(err => console.log("Error playing audio:", err));
            }
        }, { once: true });
    </script>
</body>
</html>
