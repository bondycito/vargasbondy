<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Still With You - Korean version</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            height: 100%;
        }
        body {
            background: black;
            overflow: hidden;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100vh;
            cursor: crosshair;
        }
        #subtitles {
            position: absolute;
            top: 5%;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            text-align: center;
            color: #fff799;
            font-family: sans-serif;
            font-size: 1.2rem;
            text-shadow: 1px 1px 2px #000;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            white-space: pre-wrap;
        }
        #subtitles.active {
            opacity: 1;
        }
    </style>
</head>
<body>
    <canvas id="scene"></canvas>
    <audio id="background-music" src="musica.mp3" loop></audio>
    <div id="subtitles"></div>
    <script>
        const canvas = document.getElementById("scene");
        const ctx = canvas.getContext("2d");
        const audio = document.getElementById("background-music");
        const subtitlesDiv = document.getElementById("subtitles");
        const dpr = Math.min(1.5, window.devicePixelRatio || 1);
        let cw = window.innerWidth;
        let ch = window.innerHeight;
        let baseX, baseY;
        const STAR_COUNT = 80;
        const SHOOTING_STAR_COUNT = 1;
        const FLOWER_COUNT = 7;
        const PARTICLE_CLICK_COUNT = 8;
        const PARTICLE_MOUSE_COUNT = 0.1;
        const stars = [];
        let shootingStars = [];
        let particles = [];
        const flowers = [];
        const clouds = [];
        const colors = {
            sky1: "#0a0220",
            sky2: "#120a40",
            sky3: "#1b1035",
            sky4: "#241a2e",
            horizon: "#3a1d1d",
            stemLight: "#3ba55d",
            stemDark: "#0a1f0a",
            leafBright: "#4caf50",
            leafMid: "#2e7d32",
            leafDark: "#0a2f12",
            petalLight: "#fff799",
            petalMid: "#ffe066",
            petalDark: "#ffcc00",
            center1: "#e6b53a",
            center2: "#5a3a00",
            glow: "rgba(255,255,200,0.95)"
        };
        const lyricsData = [
            { text: "날 스치는 그대의 옅은 그 목소리\n(Esa suave voz tuya que me roza)", start: 2.29, end: 7.89 },
            { text: "내 이름을 한 번만 더 불러주세요\n(Por favor, llama mi nombre una vez más)", start: 8.38, end: 13.41 },
            { text: "얼어버린 노을 아래 멈춰 서있지만\n(Estoy parado bajo la puesta de Sol congelado)", start: 13.51, end: 18.82 },
            { text: "그대 향해 한 걸음씩 걸어갈래요\n(Pero caminaré hacia ti paso a paso)", start: 19.00, end: 24.18 },
            { text: "Still with you\nStill with you", start: 24.32, end: 25.98 },
            { text: "♫♫♫♫♫♫", start: 26.04, end: 47.25 },
            { text: "어두운 방 조명 하나 없이\n(En una habitación oscura sin luz)", start: 47.50, end: 51.83 },
            { text: "익숙해지면 안 되는데\n(No debería estar acostumbrado a esto)", start: 52.32, end: 54.96 },
            { text: "그게 또 익숙해\n(Pero es tan familiar)", start: 54.98, end: 57.17 },
            { text: "나지막이 들리는 이 에어컨 소리\n(El bajo ruido De este aire acondicionado)", start: 57.20, end: 62.51 },
            { text: "이거라도 없으면 나 정말 무너질 것 같아\n(Sin esto, creo que Voy a colapsar)", start: 62.52, end: 67.95 },
            { text: "함께 웃고 함께 울고\n(Riendo juntos, llorando juntos)", start: 68.25, end: 73.78 },
            { text: "이 단순한 감정들이\n(Creo que estas simples emociones)", start: 73.86, end: 76.10 },
            { text: "내겐 전부였나 봐\n(Eran todo para mí)", start: 76.12, end: 78.97 },
            { text: "언제쯤일까 다시 그댈 마주한다면?\n(¿Cuándo será Que nos volveremos a ver cara a cara?)", start: 79.39, end: 84.29 },
            { text: "눈을 보고 말할래요 보고 싶었어요\n(Te miraré a los ojos Y te diré que te extrañé)", start: 84.44, end: 89.66 },
            { text: "황홀했던 기억 속에 나 홀로 춤을 춰도 비가 내리잖아\n(En esos bonitos recuerdos La lluvia cae, aunque bailo solo)", start: 89.86, end: 99.74 },
            { text: "이 안개가 걷힐 때쯤\n(Para cuando esta niebla se disipe)", start: 99.76, end: 103.32 },
            { text: "젖은 발로 달려갈 게\n(Correré hacia ti con los pies empapados)", start: 103.35, end: 106.11 },
            { text: "그때 날 안아줘\n(Abrázame fuerte cuando llegue ese momento)", start: 106.18, end: 111.19 },
            { text: "♫♫♫♫♫♫", start: 111.39, end: 123.17 },
            { text: "저 달이 외로워 보여서\n(La Luna se ve solitaria)", start: 123.21, end: 127.66 },
            { text: "밤하늘에 환하게 울고 있는 것 같아서\n(Como si estuviese llorando en el cielo brillante)", start: 127.69, end: 133.77 },
            { text: "언젠가 아침이 오는 걸 알면서도\n(Aunque sepa que mañana vendrá de nuevo)", start: 133.79, end: 139.20 },
            { text: "별처럼 너의 하늘에 머물고 싶었어\n(Quería quedarme en tu cielo como una estrella)", start: 139.24, end: 144.83 },
            { text: "하루를 그 순간을\n(Aquellos momentos, aquellos días)", start: 145.13, end: 150.06 },
            { text: "이렇게 될 걸 알았다면\n(Si hubiese sabido que terminarían así)", start: 150.16, end: 152.75 },
            { text: "더 담아뒀을 텐데\n(Me hubiera aferrado a ellos más)", start: 152.78, end: 155.38 },
            { text: "언제쯤일까 다시 그댈 마주한다면?\n(¿Cuándo será Que nos volveremos a ver cara a cara?)", start: 155.65, end: 160.78 },
            { text: "눈을 보고 말할래요 보고 싶었어요\n(Te miraré a los ojos Y te diré que te extrañé)", start: 160.81, end: 166.08 },
            { text: "황홀했던 기억 속에 나 홀로 춤을 춰도 비가 내리잖아\n(En esos bonitos recuerdos La lluvia cae, aunque bailo solo)", start: 166.17, end: 176.23 },
            { text: "이 안개가 걷힐 때쯤\n(Para cuando esta niebla se disipe)", start: 176.26, end: 179.73 },
            { text: "젖은 발로 달려갈 게\n(Correré hacia ti con los pies empapados)", start: 179.75, end: 182.55 },
            { text: "그때 날 잡아줘\n(Abrázame fuerte cuando llegue ese momento)", start: 182.56, end: 187.59 },
            { text: "♫♫♫♫♫♫", start: 187.59, end: 209.78 },
            { text: "날 바라보는 희미한 미소 뒤편에\n(Detrás de la suave sonrisa con la que me miraste)", start: 209.78, end: 215.15 },
            { text: "아름다운 보랏빛을 그려볼래요\n(Voy a dibujar una hermosa luz púrpura)", start: 215.58, end: 220.62 },
            { text: "서로 발걸음이 안 맞을 수도 있지만\n(Aunque nuestros pasos no estén sincronizados)", start: 220.66, end: 226.16 },
            { text: "그대와 함께 이 길을 걷고 싶어요\n(Quiero caminar este sendero contigo)", start: 226.19, end: 231.45 },
            { text: "Still with you\nStill with you", start: 231.52, end: 233.64 },
        ];
        class Particle {
            constructor(x, y, color = "white") {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 50;
                this.vy = (Math.random() - 0.5) * 50;
                this.life = 0;
                this.maxLife = 0.5 + Math.random() * 0.5;
                this.size = 1 + Math.random();
                this.color = color;
            }
            update(dt) {
                this.life += dt;
                this.x += this.vx * dt;
                this.y += this.vy * dt;
            }
            draw(ctx) {
                const alpha = 1 - (this.life / this.maxLife);
                if (alpha <= 0) return;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
            get dead() {
                return this.life >= this.maxLife;
            }
        }
        let starCounter = 0;
        class ShootingStar {
            constructor(x, y, special = false) {
                this.x = x ?? Math.random() * cw * 0.6;
                this.y = y ?? Math.random() * ch * 0.3;
                this.len = 80 + Math.random() * 100;
                this.speed = 250 + Math.random() * 250;
                this.angle = (Math.PI / 4) + (Math.random() - 0.5) * 0.25;
                this.life = 0;
                this.maxLife = 0.8 + Math.random() * 0.5;
                this.opacity = 1;
                this.special = special;
            }
            update(dt) {
                this.life += dt;
                this.x += Math.cos(this.angle) * this.speed * dt;
                this.y += Math.sin(this.angle) * this.speed * dt;
                this.opacity = 1 - (this.life / this.maxLife);
                if (Math.random() < 0.1) {
                    particles.push(new Particle(this.x, this.y, this.special ? this.rainbowColor() : "white"));
                }
            }
            rainbowColor() {
                const hue = (Date.now() / 20) % 360;
                return `hsl(${hue}, 100%, 70%)`;
            }
            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = Math.max(0, this.opacity);
                const grad = ctx.createLinearGradient(
                    this.x,
                    this.y,
                    this.x - Math.cos(this.angle) * this.len,
                    this.y - Math.sin(this.angle) * this.len
                );
                grad.addColorStop(0, this.special ? this.rainbowColor() : "rgba(255,255,255,1)");
                grad.addColorStop(1, "transparent");
                ctx.strokeStyle = grad;
                ctx.lineWidth = 1.5;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.special ? this.rainbowColor() : "white";
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x - Math.cos(this.angle) * this.len, this.y - Math.sin(this.angle) * this.len);
                ctx.stroke();
                ctx.restore();
            }
            get dead() {
                return this.life >= this.maxLife;
            }
        }
        class Flower {
            constructor(angle, height, size, swayPhase) {
                this.angle = angle;
                this.height = height;
                this.size = size;
                this.swayPhase = swayPhase;
                this.growth = 0;
                this.growthSpeed = 0.5 + Math.random() * 0.4;
                this.exploding = false;
                this.explosionScale = 1;
                this.opacity = 1;
                this.regrowDelay = 0;
            }
            update(dt) {
                if (this.regrowDelay > 0) {
                    this.regrowDelay = Math.max(0, this.regrowDelay - dt);
                    return;
                }
                if (!this.exploding && this.growth < 1) {
                    this.growth = Math.min(1, this.growth + this.growthSpeed * dt);
                }
                if (this.exploding) {
                    this.explosionScale += dt * 4.5;
                    this.opacity -= dt * 1.2;
                    if (this.opacity <= 0) {
                        this.exploding = false;
                        this.opacity = 1;
                        this.explosionScale = 1;
                        this.growth = 0;
                        this.regrowDelay = 0.6 + Math.random() * 0.8;
                        this.growthSpeed = 0.5 + Math.random() * 0.4;
                    }
                }
            }
            draw(ctx, baseX, baseY, globalSwayTime) {
                const t = this.growth;
                if (t <= 0 && !this.exploding) return;
                const radius = this.height * t;
                const swayOffset = Math.sin(globalSwayTime + this.swayPhase) * 10;
                const topX = baseX + Math.cos(this.angle) * radius + swayOffset;
                const topY = baseY - Math.sin(this.angle) * radius;
                ctx.save();
                ctx.lineWidth = 6;
                const gradStem = ctx.createLinearGradient(baseX, baseY, topX, topY);
                gradStem.addColorStop(0, colors.stemLight);
                gradStem.addColorStop(0.5, colors.stemDark);
                gradStem.addColorStop(1, "#061606");
                ctx.strokeStyle = gradStem;
                ctx.beginPath();
                ctx.moveTo(baseX, baseY);
                ctx.lineTo(topX, topY);
                ctx.stroke();
                ctx.restore();
                ctx.save();
                ctx.fillStyle = colors.leafMid;
                ctx.globalAlpha = 0.9;
                ctx.beginPath();
                ctx.ellipse(baseX + (topX - baseX) * 0.5 - 20, baseY + (topY - baseY) * 0.5, 25 * t, 12 * t, Math.PI / 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(baseX + (topX - baseX) * 0.5 + 20, baseY + (topY - baseY) * 0.5, 25 * t, 12 * t, -Math.PI / 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                if (t > 0.1 || this.exploding) {
                    ctx.save();
                    ctx.globalAlpha = this.opacity;
                    ctx.translate(topX, topY);
                    ctx.scale(this.explosionScale, this.explosionScale);
                    const flowerSize = this.size * Math.max(0.5, t);
                    for (let i = 0; i < 8; i++) {
                        ctx.save();
                        ctx.rotate((i * Math.PI) / 4);
                        const petalGrad = ctx.createRadialGradient(0, -flowerSize * 0.7, 2, 0, -flowerSize * 0.7, flowerSize);
                        petalGrad.addColorStop(0, colors.petalLight);
                        petalGrad.addColorStop(0.6, colors.petalMid);
                        petalGrad.addColorStop(1, colors.petalDark);
                        ctx.beginPath();
                        ctx.ellipse(0, -flowerSize * 0.7, flowerSize * 0.3, flowerSize * 0.7, 0, 0, Math.PI * 2);
                        ctx.fillStyle = petalGrad;
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = colors.glow;
                        ctx.fill();
                        ctx.restore();
                    }
                    const r = flowerSize * 0.4;
                    const g = ctx.createRadialGradient(0, 0, r * 0.2, 0, 0, r);
                    g.addColorStop(0, colors.center1);
                    g.addColorStop(0.7, colors.center2);
                    g.addColorStop(1, "#2a1500");
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.fillStyle = g;
                    ctx.fill();
                    ctx.restore();
                }
            }
            isClicked(x, y, baseX, baseY, globalSwayTime) {
                const t = this.growth;
                const radius = this.height * t;
                const swayOffset = Math.sin(globalSwayTime + this.swayPhase) * 10;
                const topX = baseX + Math.cos(this.angle) * radius + swayOffset;
                const topY = baseY - Math.sin(this.angle) * radius;
                const dist = Math.hypot(x - topX, y - topY);
                return dist < this.size * 1.5;
            }
        }
        
        class Cloud {
            constructor() {
                this.x = -200 - Math.random() * 300;
                this.y = ch * 0.7 + Math.random() * ch * 0.3;
                this.scale = 0.8 + Math.random() * 0.7;
                this.speed = 0.5 + Math.random() * 0.8;
                this.opacity = 0.05 + Math.random() * 0.05;
                this.blur = 15 + Math.random() * 10;
            }
            update(dt) {
                this.x += this.speed * dt * 20;
                if (this.x > cw + 300) {
                    this.x = -300 - Math.random() * 300;
                    this.y = ch * 0.7 + Math.random() * ch * 0.3;
                    this.scale = 0.8 + Math.random() * 0.7;
                    this.speed = 0.5 + Math.random() * 0.8;
                    this.opacity = 0.05 + Math.random() * 0.05;
                    this.blur = 15 + Math.random() * 10;
                }
            }
            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.fillStyle = "#fff";
                ctx.filter = `blur(${this.blur}px)`;
                ctx.beginPath();
                ctx.arc(this.x + 40 * this.scale, this.y - 20 * this.scale, 80 * this.scale, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(this.x + 120 * this.scale, this.y + 10 * this.scale, 100 * this.scale, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(this.x + 220 * this.scale, this.y - 10 * this.scale, 120 * this.scale, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
                ctx.filter = 'none';
                ctx.restore();
            }
        }

        function createStars() {
            stars.length = 0;
            for (let i = 0; i < STAR_COUNT; i++) {
                stars.push({
                    x: Math.random() * cw,
                    y: Math.random() * ch,
                    r: Math.random() * 0.8,
                    alpha: 0.25 + Math.random() * 0.75
                });
            }
        }
     function initFlowers() {
            flowers.length = 0;
            // Reduce el 'spread' para que las flores estén más juntas
            const spread = Math.PI / 3; 
            const startAngle = (Math.PI / 2) - (spread / 2); 
            
            // Define un arreglo de alturas fijas para los tallos
            // Puedes ajustar estos valores a tu gusto
            const stemHeights = [180, 150, 250, 180, 260, 160, 250];

            for (let i = 0; i < FLOWER_COUNT; i++) {
                // El ángulo para un ramito estrecho
                const angle = startAngle + (i / (FLOWER_COUNT - 1)) * spread;
                
                // Asigna una altura del arreglo de forma cíclica
                const h = stemHeights[i % stemHeights.length];
                
                // El tamaño 's' de la flor se mantiene con una pequeña variación aleatoria
                const s = 30 + Math.random() * 10;
                
                const swayPhase = Math.random() * Math.PI * 2;
                flowers.push(new Flower(angle, h, s, swayPhase));
            }
        }
        
        function initClouds() {
            clouds.length = 0;
            for(let i = 0; i < 5; i++) {
                clouds.push(new Cloud());
            }
        }
        function resize() {
            cw = window.innerWidth;
            ch = window.innerHeight;
            canvas.style.width = cw + "px";
            canvas.style.height = ch + "px";
            canvas.width = Math.floor(cw * dpr);
            canvas.height = Math.floor(ch * dpr);
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            baseX = cw / 2;
            baseY = ch;
            createStars();
            shootingStars = Array.from({ length: SHOOTING_STAR_COUNT }, () => new ShootingStar());
            initFlowers();
            initClouds();
        }
        resize();
        window.addEventListener("resize", resize);
        canvas.addEventListener("click", (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const sway = swayTime;
            for (const f of flowers) {
                if (f.isClicked(mouseX, mouseY, baseX, baseY, sway)) {
                    f.exploding = true;
                    f.explosionScale = 1;
                    f.opacity = 1;
                    for (let i = 0; i < PARTICLE_CLICK_COUNT; i++) {
                        particles.push(new Particle(baseX + Math.cos(f.angle) * f.height, baseY - Math.sin(f.angle) * f.height, colors.petalLight));
                    }
                }
            }
        });
        canvas.addEventListener("mousemove", (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            if (Math.random() < PARTICLE_MOUSE_COUNT) {
                particles.push(new Particle(x, y, "rgba(200,200,255,0.9)"));
            }
        });
        function autoShootingStar() {
            const cantidad = 1;
            for (let i = 0; i < cantidad; i++) {
                starCounter++;
                const special = starCounter % 5 === 0;
                shootingStars.push(new ShootingStar(undefined, undefined, special));
            }
            const delay = 1000 + Math.random() * 1000;
            setTimeout(autoShootingStar, delay);
        }
        autoShootingStar();
        let lastTime = performance.now();
        let swayTime = 0;
        let currentSubtitleIndex = -1;
        function animate(now) {
            let dt = (now - lastTime) / 1000;
            lastTime = now;
            if (dt > 0.05) dt = 0.05;
            swayTime += dt;
            const currentTime = audio.currentTime;
            let foundSubtitle = false;
            for (let i = 0; i < lyricsData.length; i++) {
                if (currentTime >= lyricsData[i].start && currentTime < lyricsData[i].end) {
                    if (currentSubtitleIndex !== i) {
                        subtitlesDiv.textContent = lyricsData[i].text;
                        subtitlesDiv.classList.add('active');
                        currentSubtitleIndex = i;
                    }
                    foundSubtitle = true;
                    break;
                }
            }
            if (!foundSubtitle && subtitlesDiv.classList.contains('active')) {
                subtitlesDiv.classList.remove('active');
                subtitlesDiv.textContent = '';
                currentSubtitleIndex = -1;
            }
            const grad = ctx.createLinearGradient(0, 0, 0, ch);
            grad.addColorStop(0, colors.sky1);
            grad.addColorStop(0.25, colors.sky2);
            grad.addColorStop(0.5, colors.sky3);
            grad.addColorStop(0.75, colors.sky4);
            grad.addColorStop(1, colors.horizon);
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, cw, ch);
            
            for(const cloud of clouds) {
                cloud.update(dt);
                cloud.draw(ctx);
            }

            ctx.globalAlpha = 1;
            ctx.fillStyle = "white";
            for (const s of stars) {
                ctx.globalAlpha = s.alpha;
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
            shootingStars = shootingStars.filter(s => {
                s.update(dt);
                s.draw(ctx);
                return !s.dead;
            });
            particles = particles.filter(p => {
                p.update(dt);
                p.draw(ctx);
                return !p.dead;
            });
            const sway = swayTime * 1.6;
            for (const f of flowers) {
                f.update(dt);
                f.draw(ctx, baseX, baseY, sway);
            }
            requestAnimationFrame(animate);
        }
        requestAnimationFrame(animate);
        document.addEventListener('click', () => {
            if (audio.paused) {
                audio.play();
            }
        }, { once: true });
    </script>
</body>
</html>
